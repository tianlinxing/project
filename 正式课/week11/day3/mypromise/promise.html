<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        function MyPromise(fn) {
            let self = this; // 
            self.status = 'pending';
            // status 是为了存储 promise的状态 值分别是pending resolved rejected
            self.value = ''; // 为了存储 成功的回调函数执行时传进来的参数
            self.reason = ''; // 用来存储失败的回调函数 执行时传进来的参数
            // 两个事件池
            self.resCallback = []; // 放成功回调事件的, 当走到then 中碰见状态是pending的时候
            self.rejCallback = []; // 放失败回调事件的, 当走到then 中碰见状态是pending的时候
            // 需要我们去定义两个函数 分别取对应res rej
            function resolve(val) {
                // promise 规定 状态只能从 pending 转成 rejected 或者 resoled
                // 一经改变不能再修改
                if (self.status === 'pending') {
                    // 把传进来的参数 赋给value 属性
                    self.value = val;
                    self.status = 'resolved'; // 执行成功函数 我让状态变成成功态
                    self.resCallback.forEach(item => {
                        // item 是成功池子中的成功回调
                        item && item(val);
                    });
                }

            }
            function reject(reason) {
                // promise 规定 状态只能从 pending 转成 rejected 或者 resoled
                // 一经改变不能再修改
                if (self.status === 'pending') {
                    // 把传进来的参数 赋给reason 属性
                    self.reason = reason;
                    self.status = 'rejected'; // 执行失败函数 我让状态变成失败态
                    self.rejCallback.forEach(item => {
                        // item 是失败池子中的失败回调
                        item && item(reason);
                    });
                }
            }

            try {
                // 为了处理 fn 执行失败的情况
                fn(resolve, reject);
            } catch (error) {
                // fn执行失败 直接执行 reject
                // throw error;
                reject(error);
            }

        }

        // then 函数 是在 MyPromise 原型上
        MyPromise.prototype.then = function (res, rej) {
            let self = this;
            // res2 对应的是 第二个then的成功函数 rej2 对应的是第二个then的失败函数
            let p = new MyPromise(function (res2, rej2) {
                // 怎么判断让 res 执行还是 rej执行
                // 根据当前状态去判断让哪个函数执行
                if (self.status === 'resolved') {
                    try {
                        let val = res(self.value);
                        res2(val);
                    } catch (error) {
                        rej2(error);
                    }
                }
                if (self.status === 'rejected') {
                    try {
                        // 第一个then的失败函数执行成功之后 把函数的return 值给第二个then的成功回调
                        let val = rej(self.reason);
                        res2(val);
                    } catch (error) {
                        rej2(error);
                    }

                }
                console.log(self.status);
                if (self.status === 'pending') {
                    // 当前还是等待的状态, 这种情况一般是异步造成的
                    // 若是pending状态 就把成功回调放到成功事件池
                    // self.resCallback.push(res);
                    // 若是pending状态 就把失败回调放到成功事件池
                    // self.rejCallback.push(rej);

                    self.resCallback.push(function(val) {
                        try {
                            let v = res(val);
                            res2(v)
                        } catch (error) {
                            rej2(error);
                        }
                    })
                    self.rejCallback.push(function(reason) {
                        try {
                            let v = rej(reason);
                            res2(reason);
                        } catch (error) {
                            rej2(error);
                        }
                    })
                }
            });
            return p;

        }

        let p = new MyPromise(function (res, rej) {
            // res(123);
            // rej(345);
            setTimeout(() => {
                res(123);
            }, 2000)
        });
        p.then((data) => {
            console.log(data);
            return 333
        }, (err) => {
            console.log(err);
        }).then((data2) => {
            console.log(data2);

        }, (err) => {
            console.log(err);
        });
    </script>
    <script src="./myPromise.js" type="module"></script>
    
</body>

</html>