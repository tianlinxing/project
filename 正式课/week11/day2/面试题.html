<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        /* 实现一个LazyMan，可以按照以下方式调用:
        1) LazyMan(“Hank”)输出:
        Hi! This is Hank!

        2) LazyMan(“Hank”).sleep(10).eat(“dinner”)输出
        Hi! This is Hank!
        //等待10秒..
        Wake up after 10
        Eat dinner~

            3) LazyMan(“Hank”).eat(“dinner”).eat(“supper”)输出
        Hi This is Hank!
        Eat dinner~
            Eat supper~

                4) LazyMan(“Hank”).eat(“dinner”).sleepFirst(5).eat(“supper”)输出
        //等待5秒
        Hi This is Hank!
        Wake up after 5
        Eat supper */

        class Man {
            constructor(name) {
                // Man的函数体
                // 用这个数组去存放要去执行的事件 再去设立一个专门的函数去执行数组中的事件
                this.ary = [];
                let f = () => {
                    // 定义一个事件 放到this.ary中
                    console.log(`Hi! This is ${name}`);
                    this.next();
                }

                this.ary.push(f);
                // this.next(); 不好使 是因为这时的数组是个空数组
                // 我们需要在eat 和sleep 执行完之后再去执行next函数
                setTimeout(() => {
                    // 异步函数会在同步执行完成之后再去执行
                    // 在这里使用定时器 跟时间没关系 只是需要一个异步函数
                    this.next();
                })
            }

            next() {
                let f = this.ary.shift();
                f && f();
            }


            eat(str) {
                let f = () => {
                    // 定义一个事件 放到this.ary中
                    console.log(`Eat ${str}~~`);
                    this.next();
                }

                this.ary.push(f);
                return this;
            }
            sleep(t) {
                let f = () => {
                    // 定义一个事件 放到this.ary中
                    setTimeout(() => {
                        console.log(`Wake up after ${t}`);
                        this.next();
                    }, t * 1000)
                }

                this.ary.push(f);
                return this;
            }
            sleepFirst(t) {
                let f = () => {
                    // 定义一个事件 放到this.ary中
                    setTimeout(() => {
                        console.log(`Wake up after ${t}`);
                        this.next(); // 接着调用事件池中的函数
                    }, t * 1000)
                }

                this.ary.unshift(f);
                return this;
            }

        }
        function LazyMan(name) {

            return new Man('Tom')
        }
        LazyMan('name').eat('supper').sleepFirst(5).eat('apple');

    </script>
</body>

</html>